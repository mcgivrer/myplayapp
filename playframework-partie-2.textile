WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP  


Dans le "précédent article":https://github.com/mcgivrer/myplayapp/blob/master/playframework-partie-1.textile, nous avons vu comment installer notre environnement Play! et comment travailler confortablement avec une IDE digne de ce nom, à savoir Eclipse ou bien Netbeans.
Nous avons également créé une première entité persisté via JPA (merci Java 6) et de plus réalisé une classe de test JUnit assistée par Play!.  Nous sommes presque prêt à travailler de façon professionnelle: il nous manque juste un middleware de gestion de configuration et de version.

h1. Git'ification

Certes il existe de très nombreuses solutions de gestion des versions de code sources, et le choix n'en est que plus difficile. Aussi vais-je non pas me lancer dans un comparatif des outils existant (plus ou moins libres, suivant les cas), a savoir CVS, subversion (pour les plus connu et anciens) mais aussi, git[1], mercurial(hg)[2], bazaar[3], etc..., mais directement vous en imposer un pour ce tutoriel: Git.

Et je vais même faire pire, je vous impose une plate-forme d'accueil: "github.com":http://github.com/ .
En effet, notre tutoriel est hébergé, pour des raisons on ne peut plus pratique, sur cette plate-forme Git. Je vais donc vous en expliquer l'intégration à votre projet.

En quelques mot, Git est une solution de versioning qui a l'avantage d'être non centralisée, mais obéissant au principe de distribution. Ainsi un même dépôt peut être cloné de nombreuse fois par des personnes différentes, et par la suite "fusionnés" via l'outil lui même vers un dépôt maître.

Je vous conseille pour comprendre et survivre avec Git la lecture de ce livre "Pragmatic guide to git":http://www.pragprog.com/titles/pg_git/pragmatic-guide-to-git, et de garder en référence ce document "Git Cheat Sheet":http://ktown.kde.org/~zrusin/git/git-cheat-sheet-large.png. Certes tous deux écrits dans la langue de Shakespeare, mais lecture indispensable pour une gestion des sources réussie. Pour ceux qui souhaitent aller plus loin, je vous propose la lecture de "Git Community Book"[4] qui existe également en version PDF.

h2. Création du dépôt master

Commençons par intégrer notre projet dans un dépôt maître. Pour cela, assurez vous d'avoir un compte(au passage, totalement gratuit dans le cas ou votre projet reste en accès public) chez github.com. Pour cela je vous laisse parcourir le site et la documentation mise à disposition des utilisateurs. Mais à l'issue de la création du repository de votre projet, vous vous retrouvez avec une url du style:

pre. 
    git@github.com:[username]/[projectname].git
 
C'est sur cette adresse de dépôt, que nous appellerons par la suite "master", que devra pointer votre dépôt local afin d'y pousser vos modifications.

_*nota:* N'oubliez pas, comme indiqué sur le site de github.com, d'initialiser auparavant les "variables globales GIT suivantes":http://help.github.com/git-email-settings/ :_

pre. 
    $ git config --global user.name "[user_name]"
    $ git config --global user.email "[email_for_user]@gmail.com"

_et de créer et déclarer votre "clé SSH publique":http://help.github.com/linux-key-setup/ , afin de pouvoir pousser votre matière sur le dépôt maître._

Donc, positionnons nous dans le répertoire locale de votre projet

pre. 
    $ cd ~/projets/myplayapp

et lançons l'initialisation du dépôt local avec la commande Git:

pre. 
    $ git init
  
Voilà qui est fait. Ensuite, ajoutons nos fichiers du projet et commitons ces modifications dans le dépôt local:

pre. 
    $ git add *
    $ git commit -m 'Création du projet intial'

Enfin, déclarons notre dépôt maître, poussons-y les modifications locales:

pre. 
    $ git add remote master git@github.com:[username]/[projectname].git
    $ git push origin master

où @username@ et @projectname@ correspondent à votre nom d'utilisateur sous Github et le nom de votre projet nouvellement créé via l'interface d'administration.

Voilà. Le répository local et le repository maître(master) sont créés et prêt à servir.

Penchons nous du coté d'Eclipse et voyons comment gérer notre dépôt de sources depuis cet IDE.

h2. Eclipse et EGit

Nous sommes parti dans le précédent article pour utiliser Eclipse. Afin d'optimiser notre environnement de travail, je vous propose ici l'installation d'un nouveau plugin permettant d'intégrer à Eclipse l'utilisation de Git: "Egit":http://www.eclipse.org/egit/.

Tout d'abord, un grand merci ) la fondation Eclipse pour proposer des outils aussi bien intégrer sur leur site, et ensuite, passons à l'installation qui, tenez vous bien, va être extrêmement complexe:

Via le menu "Help->install new software..." lancer la recherche sur "tous les sites "@All sites@" et rechercher "@egit@". Vous obtiendrez la fenêtre suivante :

p=. !http://lh6.ggpht.com/_n8m1NWoVppU/TUdM6mCYizI/AAAAAAAAG7I/cystTYRN0TM/s576/Capture-11-EGit-Install%20.jpg(figure 2.1 - Installation du plugin EGit sous Eclipse 3.5)!
^figure 2.1 - Installation du plugin EGit sous Eclipse 3.5^

* Cochez la case correspondante à "Eclipse EGit (Incubation) 0.10.1"
* cliquez sur "Next"
* accepter les contrats de license (GPL)
* cliquez sur Finish

Un peu de patience...

Voilà, c'est fini.

Enfin, pour découvrir toutes les finesses et subtilités de l'outil, précipitez vous vers les deux pages web suivante :

* "Git for Eclipse users":http://wiki.eclipse.org/EGit/Git_For_Eclipse_Users
* "EGit - User Guide":http://wiki.eclipse.org/EGit/User_Guide

* Si vous ouvrez de nouveau votre projet dans Eclipse (si celui-ci était ouvert tout ce temps, prenez la précaution de le fermer et de le rouvrir, pour que le plugin Egit soit correctement détecté), vous pouvez activer le contrôle de version Git via le menu contextuel en ayant auparavant sélectionné le projet dans l'explorateur du workspace.
Choisissez "Menu contextuel > Team > Share..."

p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUdO--xYpFI/AAAAAAAAG7U/N7Ok9n7QdcU/s576/Capture-2.2-Share%20Project%20.jpg(figure 2.2 - Choix du type de partage de fichier)!
^figure 2.2 - Choix du type de partage de fichier^

* Choisissez "Git", et cliquez sur "Next", un seul projet apparait dans votre workspace, sélectionnez le:

p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdO_zRWETI/AAAAAAAAG7c/gDlP0aKryH0/s576/Capture-2.3-Configure%20Git%20Repository%20.jpg(figure 2.3 - Choix du projet dans le workspace)!
^figure 2.3 - Choix du projet dans le workspace^


* Une fois le projet sélectionné, vous pouvezvalider le partage Git avec le bouton "Finish". La décoration de label liée à EGit apparaît alors dans votre explorateur de fichier, dans la side bar gauche d'Eclipse:

p=. !http://lh6.ggpht.com/_n8m1NWoVppU/TUdPArKIRCI/AAAAAAAAG7k/5M11XSzrK7g/Capture-2.4-project%20explorer%20with%20git%20label%20decoration.jpg (figure 2.4 - Mise en valeur des informations GIT dans l'explorateur de projet)!
^figure 2.4 - Mise en valeur des informations GIT dans l'explorateur de projet^

Voilà, votre projet est complètement intégré Git, et Eclipse vous permettra de travailler dans un environnement très professionnel. 

Revenons maintenant au vif du sujet et au contenu de notre projet: les plugins Play! CRUD et secure.

h1. Les plugins

Comme mentionné précédemment, nous souhaitons mettre en oeuvre deux plugins du framework Play! Ces deux plugins, pourtant natifs, ne sont pas activé par défaut. Nous allons le faire de ce pas.

h2. Activation CRUD et Secure

Pour activer un plugin engénéral, il faut éditer le fichier @[projectname]/conf/application.conf@ et se rendre vers la section traitant des ... modules !

Elle a à quelques choses prêt cette tête :

pre. 
	# Additional modules
	# ~~~~~
	# A module is another play! application. Add a line for each module you want
	# to add to your application. Modules path are either absolutes or relative to
	# the application root.
	# They get loaded from top to bottom; Syntax: module.{name}={path}
	#
	# Keep the next line as is to help the play script to manage modules.
	# ---- MODULES ----

Pour en ajouter, il suffit de procéder à l'ajout d'une ligne à la syntaxe suivante:

@module.[modulename] = ${play.path}/modules/[modulename]-[version]@

où:

* @modulename@ est le nom du module à activer dans votre projet,
* @version@ est la version cible du dit module, qui est facultatif.

h3. CRUD

Nous souhaitons donc ajouter le module CRUD:

pre. 
	module.crud=${play.path}/modules/crud

Le module apportant un certain nombre de fonctionnalités, il est accompagne de nouvelles pages qui seront dynamiquement créés. pour permettre l'accés à ces pages, nous allons devoir découvrir une nouvelle fonctionnalité de Play!:  les routes !

Commençons par finir de configurer notre module CRUD en ajoutant dans le fichier @myplayapp/conf/routes@ la ligne suivante, en fin de fichier:

pre. 
	# Import the default CRUD routes
	GET     /admin	     module:crud

Cette déclaration va permettre d'accéder au page générée dynamiquement a partir de l'url http://localhost:9000/admin, (pour un accès depuis le server play en mode run).

h3. Secure

Pour le module secure, il suffira d'ajouter la ligne:

pre. 
	module.secure=${play.path}/modules/crud


Voilà. Comme vu déjà auparavant, on s'apperçoit que les fonctionnalité de Play! sont d'une simplicité de mise en oeuvre déconcertante. Tout développeur Java se souvient des nombreux fichier de configuration qu'ils soient @.properties@, @.conf@ ou @.xml@, ils étaient dans tous les cas nombreux. Ici, point de complexité, juste du bon sens.

bq. _*nota:* Il est important de noter que suite à chaque ajout/déclaration d'un nouveau plugin dans votre projet, il est IMPERATIF de regénéré les dépendance du projet eclipse via la commande @play eclispify .@ sous peine d'avoir des erreur de compilation ainsi que des defaillances du système de complétion automatique offert par Eclipse. Cette remarque est également vraie pour NetBeans._


h2. CRUD sur mes entités ?

CRUD, pour les néofites, est un néologisme très anglicisé, correspondant à *C*reate *R*etrieve *U*pdate *D*elete, et signifiant la possibilité de fournir de façon extrêmement simple une interface utilisateur afin d'accéder aux 4 opérations de base pour chaque entité déclaré dans lepackage models.

Ainsi pour notre entité Game, nous souhaitons avoir rapodement une interface simple permettant la gestion de la liste des entités Game.

Pour celà, une simple opération permet de définir un contrôleur spécifique à notre entité. Créons la classe @Games@ dans le package @controllers@. Celle-ci doit hériter de la classe CRUD mise à disposition par le plugin précédemment activé.

La classe sera :

pre. 
	/**
	 * Project myplayapp Part 2
	 * Admin zone
	 */
	package controllers;
	
	/**
	 * CRUD management for Game entity.
	 * @author McGivrer
	 *
	 */
	public class Games extends CRUD {
	
	}

Puis, prenez votre élant et lancer le serveur play en mode DEV via la commande:

pre.
	$ play run

et constatez la beauté du geste ;)

La zone d'administration que nous accédons par "http://localhost:9000/admin":http://localhost:9000/admin donne la page ci-dessous:

p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUdY2lkxDQI/AAAAAAAAG7w/42W4htOKOcc/s460/Capture-2.5-localhost-9000-admin%20-%20Chromium.jpg(figure 2.5 - Accueil de la partie principale générée par le plugin CRUD)!
^figure 2.5 - Accueil de la partie principale générée par le plugin CRUD^

Si nous cliquons sur le lien "Games" représentant notre nouveau contrôleur, nous pouvons voir la page spécifique à notre entité Game:

p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUdY4m3Fs1I/AAAAAAAAG8E/fXzywfBN3gc/s460/Capture-2.6-localhost-9000-games-list%20-%20Chromium.jpg(figure 2.6 - Page générée par CRUD pour l'entité Game via le contrôleur Games)!
^figure 2.6 - Page générée par CRUD pour l'entité Game via le contrôleur Games^

Et enfin, si nous cliquons sur le lien "Add", situé en haut à droite de la page en cours, vous voyez alors le formulaire généré par CRUD pour la modification/création d'une (nouvelle) occurence de Game:

p=. !http://lh4.ggpht.com/_n8m1NWoVppU/TUdY684NYsI/AAAAAAAAG8Y/MZqdFWcDlF8/s460/Capture-2.7-localhost-9000-games-blank%20-%20Chromium-1.jpg(figure 2.7 - Formulaire d'édition d'une entité Game)!
^figure 2.7 - Formulaire d'édition d'une entité Game^

h3. I18n

Ok, vous me direz que ces formulaires et pages auto générés sont fort beaux, mais les labels des champs ne sont pas trop parlant. Qu'à cela ne tienne, allons modifier ces libellés.

Pour celà, penchons nous sur un autre point fort de Play! : la gestion de l'internationnalisation (le fameux i18n !).

Vous constaterez certainement, tôt ou tard, la présence, certe bizard, d'un fichier "@messages@" dans le répertoire @conf@ de votre projet Play!. Et bien, ouvrons le pour voir !

pre. 
	# You can specialize this file for each language.
	# For example, for French create a messages.fr file
	#

Bon, ok  il est vide de tout contenu, sauf d'un subtile commentaire. Et pourtant, en une seule phrase, tout est dit !

Vous voulez accéder à des textes subtilement traduit dans une langue particulières, et bien simplement créez le fichier messages.[ext] our [ext] sera le code i18 de la langue cible.

Ainsi pour nous, bon vieux français, nous devrons créer un fichier "@messages.fr@" et celui là comportera tous les message dans langue de molière que nous souhaitons voir apparaitre dans nos pages.

bq. Pour information, la sélection de la langue à afficher dans les pages pour un utilisateur se fera en fonction de la langue configurée dans les options des navigateurs web. par exemple sous firefox, ce paramétrage se trouve dans "Preferences -> Advanced -> Languages":

p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdeZkELq9I/AAAAAAAAG9E/shx3geCNqxI/s512/Capture-2.8-languages%20in%20firefox.jpg(figure 2.8 - Configuration de la langue d'affichage dans Firefox)!
^figure 2.8 - Configuration de la langue d'affichage dans Firefox^

p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdebvWfzxI/AAAAAAAAG9Y/47SwtyAKVTc/s576/Capture-2.9.1-Param%C3%A8tres%20-%20Chromium.jpg(figure 2.9.1 - Configuration de la langue d'affichage dans Chromium - étape 1)!
^figure 2.9.1 - Configuration de la langue d'affichage dans Chromium - étape 1^

p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdedG2thgI/AAAAAAAAG9s/DfZW-D9FH5E/s576/Capture-2.9.2-Param%C3%A8tres%20-%20Chromium.jpg(figure 2.9.2 - Configuration de la langue d'affichage dans Chromium - étape 2)!
^figure 2.9.2 - Configuration de la langue d'affichage dans Chromium - étape 2^

Donc, nous devons tout d'abord déclarer la liste des langues supportées par notre application. Nous nous contenterons ici,,dans le cadre de ce tutoriel, de supporter l'anglais et le français. Aussi, le fichier @conf/application.conf@ sera modifié comme suit:

pre. 
	# i18n
	# ~~~~~
	# Define locales used by your application.
	# You can then place localized messages in conf/messages.{locale} files
	application.langs=fr,en

Créons maintenant un fichier @conf/messages.fr@ pour le français, et  ajoutons-y nos libellés:

pre. 
	# You can specialize this file for each language.
	# For example, for French create a messages.fr file
	#
	title=Titre
	platform=Platforme
	description=Description
	publish=Publié
	testContent=Texte du test
	developerStudio=Studio de développement
	editor=Editeur
	yearOfPublication=Année d'édition
	note=Note
	cover=Jaquette



* ce qui donnera dans l'affichage de la page de modification de Game:
 
p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdkijKHshI/AAAAAAAAG-M/MshrtYYEmhk/s576/Capture-2.10-localhost-9000-games-blank%20-%20Google%20Chrome.jpg(figure 2.10.1 - Langue française sur le navigateur)!
 ^figure 2.10.1 - Langue française sur le navigateur^

* Si nous créons la version anglaise dans le fichier @conf/messages.en@ :

pre. 
	# You can specialize this file for each language.
	# For example, for French create a messages.fr file
	#
	title=Title
	platform=Platform
	description=Description
	publish=Publish
	testContent=Test Content
	developerStudio=Developer Studio
	editor=Editor
	yearOfPublication=Year
	note=Note
	cover=Cover



p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUdkkLqTJaI/AAAAAAAAG-g/pvt0u0yvJxc/s576/Capture-2.10.2-localhost%3A9000-games-blank%20-%20Google%20Chrome.jpg(figure 2.10.2 - Langue anglaise sur le navigateur)!
 ^figure 2.10.2 - Langue anglais sur le navigateur^

h3. Customisation de l'affichage

Si les affichage par défaut dans les liste de type d'entiés et des listes des occurences de ces entités, il est possible facilement de modifier ces affichages.

*Titre dans les Listes d'entités*

Pour modifier la liste des entités, il suffit d'ajouter dans les Entity une méthode toString() qui permettra de formater l'affichage d'un objet de type entité dans une liste. Ainsi, pour un object de type Game, on implémentera la méthode @toString()@ comme ci-dessous:

pre. 
	public String toString(){
		return this.title + "("+this.yearOfPublication+")";
	}

La liste sera alors affichée de la manière suivante :

p=. !http://lh5.ggpht.com/_n8m1NWoVppU/TUdom7ZG6jI/AAAAAAAAG-4/mVSciQoKdcs/Capture-2.11-title%20custom.jpg(figure 2.11 - Titre d'un jeu personnalisé dans la liste des Games)!
^figure 2.11 - Titre d'un jeu personnalisé dans la liste des Games^

*Colonnes affichés dans les listes*

Vous pouvez également donner plus d'information dans les listes affichées. pour cela, vous passez par les fichier @list.html@ des controllers "entities".

Pour cela, créons un répertoire @views/Games@ et dans celui-ci créer le fichier @list.html@ et copiez-y les lignes ci-dessous:

pre. 
	#{extends 'CRUD/layout.html' /}
	<div id="crudList" class="${type.name}">
		<h2 id="crudListTitle">&{'crud.list.title', type.name}</h2>
		<div id="crudListSearch">
			#{crud.search /}
		</div>
		<div id="crudListTable">
			#{crud.table fields:['title', 'yearOfPublication', 'publish', 'platform'] /}
		</div>
		<div id="crudListPagination">
			#{crud.pagination /}
		</div>
		<p id="crudListAdd">
			<a href="@{blank()}">&{'crud.add', type.modelName}</a>
		</p>
	</div>

vous remarquerez la ligne :

	@#{crud.table fields:['title', 'yearOfPublication', 'publish', 'platform'] /}@

Celle-ci liste les champs que vous souhaitez afficher dans la liste des jeux.


p=. !http://lh6.ggpht.com/_n8m1NWoVppU/TUdtwiqcqkI/AAAAAAAAG_M/L4GJ5zjh9vQ/Capture-2.12-custom%20list%20of%20fields.jpg(figure 2.12 - Liste de champs personnalisé pour la liste des jeux videos)!
^figure 2.12 - Liste de champs personnalisé pour la liste des jeux videos^

Vous remarquerz qu'ici aussi, tout les libellés sont traduits.

h2. Secure

Avant de pouvoir mettre en place la sécurité, nous avons besoin de pouvoir modéliser les utilisateurs qui pourront se connecter à notre application de gestion de liste de jeux.

Pour cela, créons l'entité User suivante:

pre. 
/**
 * User modélise un utilisateur pouvant se connecter.
 * @author McGivrer
 */
@Entity
public class User extends Model {
	public enum UserRole {
		ADMINISTRATOR,
		MODERATOR,
		USER
	}
	@Required
	@MaxSize(30)
	public String username;
	@Required
	@MinSize(4)
	@MaxSize(25)
	public String password;
	@MaxSize(50)
	public String firstname;
	@MaxSize(50)
	public String lastname;
	@Required
	@Email
	@MaxSize(100)
	public String email;
	@MaxSize(100)
	public String webblog;
	public String image="test";
	public String status="a";
	@Required
	@Enumerated(EnumType.STRING)
	public UserRole role;
	/**
	 * constructeur par défaut pour un utilisateur.
	 */
	public User(	String username,
			String password,
			String firstname,
			String lastname,
			String email,
			String webblog,
			String image,
			String status,
			UserRole role){
		this.username=username;
		this.password=password;
		this.firstname=firstname;
		this.lastname=lastname;
		this.email=email;
		this.webblog=webblog;
		this.image=image;
		this.status=status;
		this.role=role;
	}
	/**
	 * Permet l'affichage sous une forme plus accessible un objet User dans une liste (CRUD).
	 */
	public String toString(){
		return this.username+" ("+this.firstname+" "+this.lastname+")";
	}
}

Voila, nous allons bientôt pouvoir nous connecter.  Mais pour pouvoir nous connecter, il faut nous assurer qu'il y ait au moins un utilisateur utilisable dès l'installation de l'application.  Découvrons ensemble la magie du "Bootstrap" et de l'annotation @\@OnApplicationStart@.

Soit la classe ci-dessous:

pre. 
	import models.User;
	import play.jobs.Job;
	import play.jobs.OnApplicationStart;
	import play.test.Fixtures;
	@OnApplicationStart
	public class Bootstrap extends Job {
	    public void doJob() {
	        // Check if the database is empty
	        if(User.count() == 0) {
	           Fixtures.load("initial-data.yml");
	        }
	    }
	}

Si nous lisons attentivement, nous comprendrons que lors du démarrage de l'application, un Job BootStrap est lancé afin de vérifié la présence d'utilisateur dans la base de données, et le cas échéant, charge un fichier de données au format YML, permettant d'initialiser un premier utilisateur dans la base de données.

le fichier @initial-data.yml@ contient les informations suivantes:

pre. 
User(admin):
   username: admin
   password: admin
   firstname: Administrator
   lastname: Blog manager
   email: frederic.delorme@web-context.com
   weblog: http://www.mcgivrer.fr/
   image: test
   status: a
   role: ADMINISTRATOR
   
On comprend que dans cette définition, la première ligne défini l'entité à créer. Le nom entre parenthèses servira à identifier cet occurence de User dans le reste du fichier, lorsque plus-tard, nous ajouterons d'autres données. Chaque ligne suivante correspond à chacun des attributs de l'entité User. Il est ainsi très facile de pré-renseigner des informations indispensable à l'initialisation de votre application.
 
Une dernière chose, nous devons pouvoir gérer les utilisateurs.  Créons donc le controlleur de type CRUD accessible depuis la zone d'administration.

pre. 
	/**
	 * Project myplayapp Play! tutorial 
	 */
	package controllers;
	import play.mvc.With;
	/**
	 * CRUD sur les Users.
	 * @author McGivrer
	 */
	public class Users extends CRUD {
	}

Maintenant que nous avons notre User, profitons-en pour enrichir l'entité Game avec un "author" correspondant au propriétaire d'un jeu.

Ajoutons la ligne :

pre. 
	public User author;
	
et n'oublions pas de modifier le constructeur de l'entité avec le nouvel attribut:

pre. 
	public Game(String title, String Game, String description, Boolean publish,
			String testContent, String developerStudio, String editor,
			Integer yearOfPublication, Integer note, String cover, User author) {
		this.title=title;
		this.description=description;
		this.publish = publish;
		this.testContent=testContent;
		this.developerStudio=developerStudio;
		this.editor=editor;
		this.yearOfPublication = yearOfPublication;
		this.note = note;
		this.cover = cover;
		this.author = author;
	}

Ok, matérialisons clairement la relation entre User et Game dans la classe User, en ajoutant à la suite des attributs déjà déclarés:

pre. 
	@OneToMany
	public List<Game> games;
 
Ainsi, on réalise cette liste de jeux attachée à un utilisateur.

Essayer d'accéder à l'application par l'url "http://localhost:9000/admin":http://localhost:9000/admin, vous verrez apparaitre alors une nouvelle entrée dans la liste des entités gérées: @Users@. 

p=. !http://lh6.ggpht.com/_n8m1NWoVppU/TUswk_yff9I/AAAAAAAAG_o/hMFyGsgazEs/s460/Capture-2.13-Users-CRUD.jpg(figure 13 - CRUD Users)!
^figure 13 - CRUD Users^

p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUswmd4af4I/AAAAAAAAG_8/q_1hzHIk4qk/s460/Capture-2.14-Users-list.jpg(figure 14 - CRUD Users : liste des utilisateurs)!
^figure 14 - CRUD Users : liste des utilisateurs^

p=. !http://lh4.ggpht.com/_n8m1NWoVppU/TUswoJwoIEI/AAAAAAAAHAQ/bp6sVo-P4_g/s460/Capture-2.15-Users-edit.jpg(figure 15 - CRUD Users : Edition d'un User)!
^figure 15 - CRUD Users : Edition d'un User^

Ok, nous avons notre gestion d'utlisateur. Activons maintenant la sécurité.
Nous devons pour cela, fournir le service de sécurité de base à notre application. Pour cela, nous devons implezmenter notre propre version de l'objet de sécurité @controllers.Secure.Security@ proposé par Play!:

pre. 
	public class Security extends controllers.Secure.Security {
		/**
		 * Authentication method
		 * @param username
		 * @param password
		 * @return
		 */
		public static boolean authenticate(String username, String password){
			return User.connect(username,password)!=null;
		}
		/**
		 * Route to Controller/method on positive authentication
		 */
		static void onAuthenticated(){
			Administration.index();	
		}
		/**
		 * Route to Controller/Method on Diconnection
		 */
		static void onDisconnected(){
			Application.index();
		}
		/**
		 * return if User have corresponding role.
		 * @param role
		 * @return boolean value.
		 */
		static boolean check(String role) {
		    return User.find("byUsername", connected()).<User>first().isRole(role);
		}
	}

Les méthodes: 

* @public static boolean authenticate(String username, String password);@
C'est la méthode qui est appelée par l'objet dont notre @Security@ hérite lorsqu'un utilisateur tente d'accéder à un contrôleur sécurisé. 

* @static void onAuthenticated();@
Une fois authentifié, l'évènement onAuthenticated est appelé. Ici, vous appelez l'action du contrôleur correspondant à la page vers laquelle vous souhaitez que l'utilisateur soit routé en cas de succès.

* @static void onDisconnected();@
Lorsque l'utilisateur se déconnecter (nous verrons plus tard comment l'on traite cette évènement), @onDisctonneted()@ est appelé. A vous d'appeler votre traitement préféré pour la déconnection. N'oubliez pas de finir en appelant la méthode/contrôleur pour router l'utilisateur vers une page précise.

* @static boolean check(String profile);@
Cette permet de vérifier si le profile de l'utilisateur.

Dans notre cas, nous allons déléguer l'authentification à l'objet User. Nous appelons la méthode connect() de User.

pre. 
	/**
	 * Find Method to implement user connection. 
	 * @param email
	 * @param password
	 * @return
	 */
	public static User connect(String username, String password){
		return User.find("byUsernameAndPassword",username,password).first();
	}

Ici, l'utilisateur sera identifié par son @username@ et son @password@. Vous pouvez d'ailleurs constater la facilité d'utilisation de la méthode @find()@ de la couche JPA proposée par Play!
la simple chaîne @"byUsernameAndPassword"@ permet de tester l'égalité des champs username et password.

Ensuite, notons la délégation de la vérification du profil d'un utilisateur à la méthode @User.isRole(String role)@. Un moyen simple d'externaliser ce traitement.

Soit dans la classe user:

pre. 
	/**
	 * check if user have Administrator profile.
	 * @return
	 */
	public boolean isRole(String role){
		return role.equals(this.role.toString());
	}

Donc comment active-t-on maintenant la sécurité sur un contrôleur ?

Nous allons mettre en oeuvre cette sécurité dans un nouveau contrôleur:

pre. 
	/**
	 * Project myplayapp tutorial
	 */
	package controllers;
	import play.*;
	import play.mvc.*;
	import java.util.*;
	import models.*;
	/**
	 * Contrôleur de la zone de sécurité
	 * @author McGivrer
	 */
	@With(Security.class)
	public class Administration extends Controller {
		/**
		 * récupération de l'utilisateur connecté.
		 */
	    @Before
	    static void setConnectedUser() {
	        if(Security.isConnected()) {
	            User user = User.find("byEmail", Security.connected()).first();
	            renderArgs.put("user", user);
	        }
	    }
	    /**
	     * Page d'accueil par défaut du contrôleur.
	     */
	    public static void index() {
	    	List<Game> games=Game.find("byAuthor",((User)renderArgs.get("user"))).fetch();
	        render(games);
	    }
	}

Toute l'astuce se résume à la simple annotation @\@With(Security.class)@. Et la magie de Play! agit.

Allons plus loins dans la magie.

Nous souhaitons limiter l'accès à un contrôleur, par exemple notre nouveau "Games" héritant de CRUD, à la population des administrateurs. Nous allons donc demander à la sécurité applicative de tester le role des utilisateur qui se connecte.

Attention, ca va être très complexe, suivez bien !

pre. 
	/**
	 * Project myplayapp Play! tutorial
	 * Admin zone
	 */
	package controllers;
	import play.mvc.With;	
	/**
	 * CRUD management for Game entity.
	 * @author frederic
	 *
	 */
	@Check("ADMINISTRATOR")
	@With(Security.class)
	public class Games extends CRUD {
	}

la vérification d'un rôle est réalisé par l'appel à la notation @"@Check("ADMINISTRATOR")"@.  Ici, donc, est vérifié le rôle "Administrateur" (UserRole.ADMINISTRATOR) de l'utilisateur.

Maintenant que nous avons quelque-peu avancé, je vous propose de modifier le template par défaut de l'ensemble des pages du site. Pour cela, éditons le fichier @myplayapp/app/view/main.html@ et remplaçons contenu par les lignes suivantes:

pre. 
	<!DOCTYPE html>
	
	<html>
	    <head>
	        <title>#{get 'title' /}</title>
	        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	        <link rel="stylesheet" type="text/css" media="screen" href="@{'/public/stylesheets/main.css'}">
	        #{get 'moreStyles' /}
	        <link rel="shortcut icon" type="image/png" href="@{'/public/images/favicon.png'}">
	        <script src="@{'/public/javascripts/jquery-1.4.2.min.js'}" type="text/javascript" charset="utf-8"></script>
	        #{get 'moreScripts' /}
	    </head>
	    <body>
	    	<header>
	    		<h1>&{'site.title'}</h1>
	    		<h2>&{'site.subtitle'}</h2>
	    		<nav>
	    			<ul>
	    				#{if !user}
		    				<li><a href="@{Application.login()}" title="&{'home.actions.login.label'}">&{'home.actions.login'}</a></li>
	    				#{/if}
	    				#{else}
		    				<li><a href="@{Application.logout()}" title="&{'home.actions.logout.label'}">&{'home.actions.logout'}</a></li>
	    				#{/else}
	    			</ul>
	    		</nav>
	    	</header>
	    	<section id="content">
		        #{doLayout /}
	    	</section>
	    	<footer>
	    		<p>&{'site.footer.label'}</p>
	    	</fooyter>
	    </body>
	</html>

Première chose, vous constaterez le fait que nous travaillons avec HTML5 et non le traditionnel HTML 4.01 ou l'XHTML. D'où l'introduction des nouveaux tags @header@, @section@ et @footer@. Les lignes contenues dans le @HEAD@ sont celles générée par le framework.

Par contre les lignes du body sont largement retouchée. Dans le @header@ de la page, soit la zone de titre, nous avons ajouté un titre, un sous-titre ainsi qu'un menu, proposant le nouveau tag HTML5 @nav@.

Dans ce menu de navigation sont présentes deux actions:  login et logout.  elle se passe de commentaire, si ce n'est que leur affichage est exclusif.



h1. Page d'accueil personnalisée

Comme prévu, nous souhaitons créer notre propre page d'accueil (sinon, où est l'intérêt ? :)

Aussi, voici ce que nous souhaitons obtenir:

p=. !http://lh3.ggpht.com/_n8m1NWoVppU/TUsywpNZplI/AAAAAAAAHAo/2gA044DjJx8/Capture-2.16-index.jpg(figure 16 - Page d'accueil personnalisée)!
^figure 16 - Page d'accueil personnalisée^

Ce qui se traduit côté code "HTML/Groovy" par les lignes suivantes:

pre. 
	#{extends 'main.html' /}
	<div id="games" class="games">
		<h1>&{'home.games.title'}</h1>
		#{if games}
			#{list items:games, as:'game'}
				#{set title:'Home / '+game.platform+'/'+game.title /}
				<div class="game" id="game_${game.id}">
						<div class="title"><span>#${game.id}.</span> ${game.platform}/${game.title}</div>
					<div class="side">
						#{if game.cover}
						<div class="cover">
							<img src="public/images/games/${game.platform}/${game.title}/cover/${game.cover}.resized" 
								title="${game.platform}/${game.title}" width="60"/>
						</div>
						#{/if}
						<div class="tags">
						</div>
					</div>
					<div class="info">
						#{if game.description}
						<div class="label">&{'home.games.game.description'}</div>
						<div class="bloc">${game.description}</div>
						#{/if}
						#{if game.testContent}
						<div class="label">&{'home.games.game.test'}</div>
						<div class="bloc">${game.testContent}</div>
						#{/if}
					</div>
				</div>
			#{/list}
		#{/if}
		#{else}
			<p>&{'home.games.noitems'}</p>
		#{/else}
	</div> 

On distingue plusieurs notations utiles:

* @&{}@ permet la lecture de messages issus des fichier @"messages.[langue]"@, exemple: &{'home.games.title'}
* @#{}@ permet les tests de structures et boucles,
* @${}@ permet la lecture de variables d'entités.

Les méthodes intéressantes sont:

* @#{if}#{/if}@ délimite une condition
* @#{else}#{/else}@ délimite le cas échéant de la condition
* @#{list items:[liste], as:'[item]'}@ permet de parcourir une liste [liste] avec comme index l'objet [item]. il est alors possible de référencer chaque occurense dans la liste par "item.attribut, où attribut est un attribut valorisé de l'occurence.

Référez vous à la "documentation":http://www.playframework.org/documentation/1.0.1/templates présente sur le site de Play! pour découvrir toutes les subtilités de Groovy, qui est le langage utilisé ici.




h1. Références


fn1. site de Git "http://git-scm.com/":http://git-scm.com/

fn2. Site de Mercurial (Hg) tools "http://mercurial.selenic.com/":http://mercurial.selenic.com/

fn3. Site de Bazaar "http://bazaar.canonical.com/en/":http://bazaar.canonical.com/en/

fn4. Livre sur Git écrit par la communauté d'utilisateur: "http://book.git-scm.com/":http://book.git-scm.com/

WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP - WIP